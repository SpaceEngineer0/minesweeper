<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.25">
	<link rel="icon" type="image/png" href="images/mine.png">
	<link rel="stylesheet" type="text/css" href="./styles.css">
	<title>Minesweeper</title>
</head>
<body>
	<div class="header">
		<img src="./images/mine.png" alt="logo" class="logo">
		<div class="title">Minesweeper</div>
	</div>
	<div class="bar">
		<select class="diffSelector">
			<option value="0" selected>9x9</option>
			<option value="1">19x19</option>
		</select>
		<button type="button" class="restartButton">Restart</button>
	</div>
	<div class="textEl">10</div>
	<div class="board"></div>
	<script>
		const boardElement = document.querySelector('.board');
		const difficultySelector = document.querySelector('.diffSelector');
		const restartButton = document.querySelector('.restartButton');
		const root = document.documentElement;
		const textElement = document.querySelector('.textEl');

		var size = 9;
		var board = [];
		var mineCount = 10;

		restartButton.addEventListener('click', () => {
			if (difficultySelector.value === '0') {
				size = 9;
				mineCount = 10;
			}
			else if (difficultySelector.value === '1') {
				size = 19;
				mineCount = 50;
			}
			startGame(size, mineCount);
		});

		startGame(size, mineCount);

		function startGame(size, mineCount) {
			var clickCounter = 0;
			board = createBoard(size, mineCount);
			root.style.setProperty('--gridSize', size);
			textElement.style.setProperty('color', '#eb2b2b')
			textElement.textContent = mineCount;
			boardElement.innerHTML = '';
			boardElement.classList.remove('noHover');
			boardElement.addEventListener('contextmenu', e => e.preventDefault());

			board.forEach(row => {
				row.forEach(tile => {
					boardElement.append(tile.element);
					tile.element.addEventListener('click', () => {
						if (tile.status !== 'hidden') return;
						if (tile.isMine && clickCounter === 0) {
							spawnMine(board, size);
							tile.isMine = false;
						}

						revealTile(board, tile);
						textElement.textContent = mineLeftCount(board, mineCount);
						checkEnd(board);
						clickCounter++;
					})
					tile.element.addEventListener('contextmenu', e => {
						if (tile.status === 'hidden') tile.status = 'flag';
						else if (tile.status === 'flag') tile.status = 'hidden';

						textElement.textContent = mineLeftCount(board, mineCount);
						e.preventDefault();
						checkEnd(board);
					})
				})
			})
		}

		function checkEnd(board) {
			const win = checkWin(board);
			const lose = checkLose(board);

			if (win || lose) boardElement.classList.add('noHover');

			if (win) {
				textElement.style.setProperty('color', '#3ea0f7');
				textElement.textContent = 'You won!';
				board.forEach(row => {
					row.forEach(tile => {
						if (tile.isMine) tile.status = 'flag';
					})
				})
			}

			if (lose) {
				textElement.style.setProperty('color', '#eb2b2b');
				textElement.textContent = 'You lose!';
				board.forEach(row => {
					row.forEach(tile => {
						if (tile.isMine && tile.status !== 'flag') revealTile(null, tile);
						if (!tile.isMine && tile.status === 'flag') tile.element.classList.add('incorrect');
					})
				})
			}
		}

		function createBoard(size, mineCount) {
			var board = [];
			for (let x = 0; x < size; x++) {
				board.push([]);
				for (let y = 0; y < size; y++) {
					const element = document.createElement('div');
					element.dataset.status = 'hidden';
					const tile = {
						isMine: false,
						element,
						x,
						y,
						get status() {
							return this.element.dataset.status;
						},
						set status(value) {
							this.element.dataset.status = value;
						}
					}
					board[x].push(tile);
				}
			}

			for (let i = 0; i < mineCount; i++) spawnMine(board, size);
			return board;
		}

		function spawnMine(board, size) {
			const x = randomNumber(size);
			const y = randomNumber(size);
			const tile = board[x][y];
			if (!tile.isMine) tile.isMine = true;
			else spawnMine(board, size);
		}

		function revealTile(board, tile) {
			if (tile.isMine) tile.status = 'mine';
			if (tile.status === 'hidden') {
				const adjacentTiles = nearbyTiles(board, tile);
				const mineCount = adjacentTiles.filter(tile => tile.isMine).length;
				tile.element.textContent = mineCount;
				tile.status = 'number';

				switch (mineCount) {
					case 0:
						tile.element.textContent = '';
						adjacentTiles.forEach(t => revealTile(board, t));
						break;
					case 1: tile.element.classList.add('num1'); break;
					case 2: tile.element.classList.add('num2'); break;
					case 3: tile.element.classList.add('num3'); break;
					case 4: tile.element.classList.add('num4'); break;
					case 5: tile.element.classList.add('num5'); break;
					case 6: tile.element.classList.add('num6'); break;
					case 7: tile.element.classList.add('num7'); break;
					case 8: tile.element.classList.add('num8'); break;
				}
			}
		}

		function nearbyTiles(board, { x, y }) {
			const tiles = [];
			for (let xOffset = -1; xOffset <= 1; xOffset++) {
				for (let yOffset = -1; yOffset <= 1; yOffset++) {
					const tile = board[x + xOffset]?.[y + yOffset];
					if (tile) tiles.push(tile);
				}
			}
			return tiles;
		}

		function randomNumber(max) {
			return Math.floor(Math.random() * max);
		}

		function checkWin(board) {
			return board.every(row => {
				return row.every(tile => {
					return (tile.status === 'number' || tile.isMine && (tile.status === 'hidden' || tile.status === 'flag'));
				})
			})
		}

		function checkLose(board) {
			return board.some(row => {
				return row.some(tile => {
					return tile.status === 'mine';
				})
			});
		}

		function mineLeftCount(board, maxMines) {
		var count = maxMines;
		board.forEach(row => {
			row.forEach(tile => {
				if (tile.status === 'flag') count--;
			})
		})
		return count;
	}
	</script>
</body>
</html>